---
// SearchOverlay.astro - Search modal overlay using <dialog> for proper iOS Safari viewport handling
---

<dialog
    data-search-overlay
    class="search-dialog"
    aria-label="Site Search"
>
    <!-- Backdrop close button -->
    <button
        type="button"
        class="search-dialog__backdrop"
        data-search-close
        aria-label="Close Search"
    ></button>

    <!-- Search Container -->
    <div
        data-search-container
        class="search-dialog__container translate-y-4 transition-transform duration-200"
    >
        <!-- Search Header -->
        <div class="flex items-center gap-3 border-b border-subtle pb-3">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="h-5 w-5 shrink-0 text-muted"
                aria-hidden="true"
            >
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.3-4.3"></path>
            </svg>
            <label for="search-input" class="sr-only">Search Posts</label>
            <input
                id="search-input"
                type="search"
                placeholder="Search posts..."
                class="w-full bg-transparent text-lg text-primary placeholder:text-muted focus-accent rounded"
                data-search-input
                autocomplete="off"
            />
            <kbd
                class="hidden shrink-0 rounded border border-subtle bg-page px-2 py-0.5 text-xs text-muted sm:inline-block"
                aria-hidden="true"
            >
                ESC
            </kbd>
            <button
                type="button"
                class="icon-btn icon-btn--sm icon-btn--square focus-accent sm:hidden"
                data-search-close
                aria-label="Close Search"
            >
                <span aria-hidden="true" class="text-xl leading-none">&times;</span>
            </button>
        </div>

        <!-- Search Results -->
        <div
            data-search-results
            data-scroll-container
            class="max-h-[60vh] overflow-y-auto py-3"
        >
            <!-- Empty state -->
            <div data-search-empty class="py-8 text-center text-muted">
                <p>Enter keywords to search</p>
                <p class="mt-2 text-sm">Search all posts</p>
            </div>
            <!-- No results state (hidden by default) -->
            <div data-search-no-results class="hidden py-8 text-center text-muted">
                <p>No results found</p>
                <p class="mt-2 text-sm">Try different keywords</p>
            </div>
            <!-- Results list -->
            <ul data-search-list class="hidden space-y-2" role="listbox" aria-label="Search Results">
            </ul>
        </div>

        <!-- Search Footer -->
        <div class="flex items-center justify-between border-t border-subtle pt-3 text-xs text-muted">
            <span>
                <kbd class="rounded border border-subtle bg-page px-1.5 py-0.5">↵</kbd>
                Select
                <kbd class="ml-2 rounded border border-subtle bg-page px-1.5 py-0.5">↑↓</kbd>
                Navigate
            </span>
            <span class="flex items-center gap-1">
                <span>Powered by</span>
                <a
                    href="https://pagefind.app/"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="text-accent hover:underline focus-accent rounded"
                >
                    Pagefind
                </a>
            </span>
        </div>
    </div>
</dialog>

<script>
    import { lockScrollForDialog, unlockScrollForDialog } from "../utils/scrollLock";

    function initSearchOverlay() {
        const searchTrigger = document.querySelector<HTMLButtonElement>("[data-search-trigger]");
        const searchDialog = document.querySelector<HTMLDialogElement>("[data-search-overlay]");
        const searchContainer = document.querySelector<HTMLElement>("[data-search-container]");
        const searchInput = document.querySelector<HTMLInputElement>("[data-search-input]");
        const searchCloseButtons = document.querySelectorAll<HTMLButtonElement>("[data-search-close]");
        const searchEmpty = document.querySelector<HTMLElement>("[data-search-empty]");
        const searchNoResults = document.querySelector<HTMLElement>("[data-search-no-results]");
        const searchList = document.querySelector<HTMLElement>("[data-search-list]");

        let lastFocusedElement: Element | null = null;
        let pagefind: any = null;
        let selectedIndex = -1;

        async function loadPagefind() {
            if (pagefind) return pagefind;
            try {
                // Use variable to prevent Vite from resolving at build time
                const pagefindPath = "/pagefind/pagefind.js";
                pagefind = await import(/* @vite-ignore */ pagefindPath);
                await pagefind.init();
                return pagefind;
            } catch (e) {
                console.error("Failed to load Pagefind:", e);
                return null;
            }
        }

        function createResultItem(result: any, index: number) {
            const li = document.createElement("li");
            li.setAttribute("role", "option");
            li.setAttribute("aria-selected", "false");

            const link = document.createElement("a");
            link.href = result.url;
            link.className = "search-result-item group flex flex-col gap-1 rounded-lg p-3 transition-colors hover:bg-accent-tint-8 focus:bg-accent-tint-8 focus:outline-none";
            link.dataset.searchResultIndex = String(index);

            const title = document.createElement("span");
            title.className = "font-medium text-primary group-hover:text-accent group-focus:text-accent";
            title.textContent = result.meta?.title || result.url;

            const excerpt = document.createElement("span");
            excerpt.className = "line-clamp-2 text-sm text-secondary search-excerpt";
            if (result.excerpt) {
                excerpt.innerHTML = result.excerpt;
            }

            link.appendChild(title);
            link.appendChild(excerpt);
            li.appendChild(link);

            return li;
        }

        async function performSearch(query: string) {
            if (!query.trim()) {
                showEmpty();
                return;
            }

            const pf = await loadPagefind();
            if (!pf) return;

            const search = await pf.search(query);

            if (search.results.length === 0) {
                showNoResults();
                return;
            }

            const results = await Promise.all(
                search.results.slice(0, 10).map((r: any) => r.data())
            );

            showResults(results);
        }

        function showEmpty() {
            searchEmpty?.classList.remove("hidden");
            searchNoResults?.classList.add("hidden");
            searchList?.classList.add("hidden");
            selectedIndex = -1;
        }

        function showNoResults() {
            searchEmpty?.classList.add("hidden");
            searchNoResults?.classList.remove("hidden");
            searchList?.classList.add("hidden");
            selectedIndex = -1;
        }

        function showResults(results: any[]) {
            searchEmpty?.classList.add("hidden");
            searchNoResults?.classList.add("hidden");
            searchList?.classList.remove("hidden");

            if (!searchList) return;

            searchList.replaceChildren();

            results.forEach((result, index) => {
                const item = createResultItem(result, index);
                searchList.appendChild(item);
            });

            selectedIndex = -1;
        }

        function updateSelection(newIndex: number) {
            const items = searchList?.querySelectorAll<HTMLElement>("[data-search-result-index]");
            if (!items || items.length === 0) return;

            if (newIndex < 0) newIndex = items.length - 1;
            if (newIndex >= items.length) newIndex = 0;

            items.forEach((item, i) => {
                const li = item.closest("li");
                if (i === newIndex) {
                    li?.setAttribute("aria-selected", "true");
                    item.classList.add("bg-accent-tint-8");
                    item.focus();
                } else {
                    li?.setAttribute("aria-selected", "false");
                    item.classList.remove("bg-accent-tint-8");
                }
            });

            selectedIndex = newIndex;
        }

        function setSearchOpen(open: boolean) {
            if (!searchDialog || !searchContainer) return;

            if (open) {
                lastFocusedElement = document.activeElement;
                searchDialog.showModal();
                lockScrollForDialog();
                // Animate in next frame
                requestAnimationFrame(() => {
                    searchDialog.classList.add("is-open");
                });
                requestAnimationFrame(() => {
                    searchInput?.focus();
                    searchInput?.select();
                });
            } else {
                searchDialog.classList.remove("is-open");
                unlockScrollForDialog();
                // Close dialog after transition
                setTimeout(() => {
                    if (!searchDialog.classList.contains("is-open")) {
                        searchDialog.close();
                    }
                }, 200);
                if (lastFocusedElement && "focus" in lastFocusedElement) {
                    (lastFocusedElement as HTMLElement).focus();
                }
                if (searchInput) searchInput.value = "";
                showEmpty();
            }
        }

        searchTrigger?.addEventListener("click", () => setSearchOpen(true));
        searchCloseButtons.forEach((btn) =>
            btn.addEventListener("click", () => setSearchOpen(false))
        );

        // Intercept browser Escape to run animated close instead
        searchDialog?.addEventListener("cancel", (e) => {
            e.preventDefault();
            setSearchOpen(false);
        });

        document.addEventListener("keydown", (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === "k") {
                e.preventDefault();
                setSearchOpen(true);
                return;
            }

            if (!searchDialog?.open) return;

            if (e.key === "Escape") {
                e.preventDefault();
                setSearchOpen(false);
                return;
            }

            if (e.key === "ArrowDown") {
                e.preventDefault();
                updateSelection(selectedIndex + 1);
            } else if (e.key === "ArrowUp") {
                e.preventDefault();
                updateSelection(selectedIndex - 1);
            } else if (e.key === "Enter" && selectedIndex >= 0) {
                const items = searchList?.querySelectorAll<HTMLElement>("[data-search-result-index]");
                const selected = items?.[selectedIndex];
                if (selected) {
                    e.preventDefault();
                    selected.click();
                }
            }
        });

        let debounceTimer: ReturnType<typeof setTimeout>;
        searchInput?.addEventListener("input", (e) => {
            const query = (e.target as HTMLInputElement).value;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => performSearch(query), 200);
        });
    }

    initSearchOverlay();
    document.addEventListener("astro:after-swap", initSearchOverlay);
</script>

<style>
    /* Pagefind highlight styles */
    .search-excerpt :global(mark) {
        background-color: var(--color-accent-soft);
        color: var(--color-accent-dark);
        border-radius: 2px;
        padding: 0 2px;
    }
</style>
